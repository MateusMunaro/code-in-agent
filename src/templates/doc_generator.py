"""
Documentation Generator.

Orchestrates the generation of complete, structured documentation
for an analyzed codebase.
"""

import json
from dataclasses import dataclass
from datetime import datetime
from typing import Optional
from pathlib import Path

from .doc_structure import (
    DocumentationStructure,
    DocCategory,
    DocTemplate,
    FOLDER_STRUCTURE,
)
from .agent_guidelines import generate_agent_guidelines


@dataclass
class AnalysisResult:
    """Results from codebase analysis."""
    project_name: str
    architecture_pattern: str
    confidence: float
    main_language: str
    framework: Optional[str]
    patterns_detected: list
    files_read: list
    tech_stack: dict
    directory_structure: str
    dependency_graph: dict
    improvements: list
    entry_points: list
    key_modules: list


class DocumentationGenerator:
    """
    Generates complete structured documentation from analysis results.
    
    Creates a full docs/ folder structure with:
    - Visual diagrams (Mermaid)
    - Context documentation
    - Usage guides
    - Agent rules
    """
    
    def __init__(self, analysis: AnalysisResult):
        self.analysis = analysis
        self.date = datetime.now().strftime("%B %d, %Y")
        self.doc_structure = DocumentationStructure(
            project_name=analysis.project_name,
            architecture_pattern=analysis.architecture_pattern,
            tech_stack=analysis.tech_stack,
            patterns_detected=analysis.patterns_detected,
        )
    
    def generate_full_documentation(self) -> dict[str, str]:
        """
        Generate all documentation files.
        
        Returns:
            Dictionary mapping file paths to content
        """
        docs = {}
        
        # 1. Generate folder structure overview
        docs["docs/STRUCTURE.md"] = self._generate_structure_overview()
        
        # 2. Generate Agent Rules (root level)
        docs["docs/AGENT_RULES.md"] = self._generate_agent_rules()
        
        # 3. Generate Charts documentation
        docs.update(self._generate_charts_docs())
        
        # 4. Generate Context documentation  
        docs.update(self._generate_context_docs())
        
        # 5. Generate Usage guides
        docs.update(self._generate_usage_docs())
        
        return docs
    
    def generate_summary_documentation(self) -> str:
        """
        Generate a single comprehensive documentation file.
        
        Use this when you want all documentation in one file
        instead of the full folder structure.
        """
        return f"""# üìö Project Documentation - {self.analysis.project_name}

> Documentation automatically generated by Code Analysis Agent.
> Analysis performed on {self.date}

---

## üìã Index

1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Project Structure](#project-structure)
4. [Detected Patterns](#detected-patterns)
5. [Technology Stack](#technology-stack)
6. [Rules for AI Agents](#rules-for-ai-agents)
7. [Improvement Recommendations](#improvement-recommendations)
8. [Recommended Documentation Structure](#recommended-documentation-structure)

---

## Overview

**Project:** {self.analysis.project_name}  
**Architecture:** {self.analysis.architecture_pattern}  
**Analysis Confidence:** {self.analysis.confidence:.0%}  
**Main Language:** {self.analysis.main_language}  
{f"**Framework:** {self.analysis.framework}" if self.analysis.framework else ""}

### Statistics

- **Files analyzed:** {len(self.analysis.files_read)}
- **Patterns detected:** {len(self.analysis.patterns_detected)}
- **Recommendations:** {len(self.analysis.improvements)}

---

## Architecture

### Architectural Pattern: {self.analysis.architecture_pattern}

{self._generate_architecture_description()}

### Architecture Diagram

```mermaid
{self._generate_architecture_mermaid()}
```

---

## Project Structure

```
{self.analysis.directory_structure}
```

### Key Modules

{self._generate_key_modules_description()}

### Entry Points

{self._generate_entry_points_description()}

---

## Detected Patterns

{self._generate_patterns_section()}

---

## Technology Stack

{self._generate_tech_stack_section()}

---

## Rules for AI Agents

{self._generate_agent_rules()}

---

## Improvement Recommendations

{self._generate_improvements_section()}

---

## Recommended Documentation Structure

For a well-documented project, we recommend creating the following structure:

```
{FOLDER_STRUCTURE}
```

### Why This Structure?

1. **`charts/`** - Visual diagrams (Mermaid) for quick understanding
2. **`context/`** - Reference documentation for consultation
3. **`usage/`** - Practical guides for common tasks
4. **`implementations/`** - History of decisions and implementations
5. **`AGENT_RULES.md`** - Specific rules for AI agents

### Benefits

- ‚úÖ AI agents find context quickly
- ‚úÖ New developers orient themselves easily
- ‚úÖ Modular and scalable documentation
- ‚úÖ Decision trees guide to the right document

---

*Generated by Code Analysis Agent on {self.date}*
"""

    def _generate_structure_overview(self) -> str:
        """Generate documentation structure overview."""
        return f"""# üìÅ Documentation Structure - {self.analysis.project_name}

> This file explains the documentation organization.

## Folder Structure

```
{FOLDER_STRUCTURE}
```

## How to Navigate

1. **Starting?** ‚Üí Read `AGENT_RULES.md` first
2. **Writing code?** ‚Üí Go to `usage/00_INDEX.md`
3. **Understanding the system?** ‚Üí Go to `charts/00_INDEX.md`
4. **Looking up reference?** ‚Üí Search in `context/`

---

*Generated by Code Analysis Agent on {self.date}*
"""

    def _generate_agent_rules(self) -> str:
        """Generate agent rules using the generator."""
        return generate_agent_guidelines(
            project_name=self.analysis.project_name,
            architecture_pattern=self.analysis.architecture_pattern,
            main_language=self.analysis.main_language,
            framework=self.analysis.framework,
            patterns_detected=self.analysis.patterns_detected,
            tech_stack=self.analysis.tech_stack,
            entry_points=self.analysis.entry_points,
            key_modules=self.analysis.key_modules,
        )

    def _generate_charts_docs(self) -> dict[str, str]:
        """Generate charts documentation."""
        docs = {}
        
        # Index
        docs["docs/charts/00_INDEX.md"] = self._generate_charts_index()
        
        # Architecture Overview
        docs["docs/charts/01_ARCHITECTURE_OVERVIEW.md"] = self._generate_architecture_overview()
        
        # Class/Entity Diagram
        docs["docs/charts/02_CLASS_DIAGRAM.md"] = self._generate_class_diagram()
        
        # Sequence Flows
        docs["docs/charts/03_SEQUENCE_FLOWS.md"] = self._generate_sequence_flows()
        
        # Component Diagram
        docs["docs/charts/04_COMPONENT_DIAGRAM.md"] = self._generate_component_diagram()
        
        # Data Flow
        docs["docs/charts/05_DATA_FLOW.md"] = self._generate_data_flow_diagram()
        
        # Dependency Graph
        docs["docs/charts/06_DEPENDENCY_GRAPH.md"] = self._generate_dependency_graph_doc()
        
        return docs

    def _generate_context_docs(self) -> dict[str, str]:
        """Generate context documentation."""
        docs = {}
        
        docs["docs/context/ARCHITECTURE.md"] = self._generate_architecture_context()
        docs["docs/context/COMPONENTS.md"] = self._generate_components_catalog()
        docs["docs/context/PATTERNS.md"] = self._generate_patterns_catalog()
        docs["docs/context/TECH_STACK.md"] = self._generate_tech_stack_doc()
        
        return docs

    def _generate_usage_docs(self) -> dict[str, str]:
        """Generate usage guides."""
        docs = {}
        
        docs["docs/usage/00_INDEX.md"] = self._generate_usage_index()
        docs["docs/usage/01_GETTING_STARTED.md"] = self._generate_getting_started()
        docs["docs/usage/02_CODE_PATTERNS.md"] = self._generate_code_patterns_guide()
        docs["docs/usage/03_DATA_FLOW.md"] = self._generate_data_flow_guide()
        docs["docs/usage/04_ADDING_FEATURES.md"] = self._generate_adding_features_guide()
        
        return docs

    # =========================================
    # HELPER METHODS FOR CONTENT GENERATION
    # =========================================

    def _generate_charts_index(self) -> str:
        """Generate charts index."""
        return f"""# üìä Visual Documentation - {self.analysis.project_name}

> Diagrams and visual documentation for global project context.

## üìÅ Document Structure

| # | Document | Description |
|---|----------|-------------|
| 01 | [System Architecture](./01_ARCHITECTURE_OVERVIEW.md) | Architecture overview and structure |
| 02 | [Class Diagram](./02_CLASS_DIAGRAM.md) | Domain model and entities |
| 03 | [Flows and Sequences](./03_SEQUENCE_FLOWS.md) | Main operation flows |
| 04 | [Components](./04_COMPONENT_DIAGRAM.md) | Module hierarchy |
| 05 | [Data Flow](./05_DATA_FLOW.md) | How data flows |
| 06 | [Dependencies](./06_DEPENDENCY_GRAPH.md) | Dependency graph |

---

## üéØ How to Use

### For New Developers
1. Start with [01_ARCHITECTURE_OVERVIEW](./01_ARCHITECTURE_OVERVIEW.md)
2. Read [02_CLASS_DIAGRAM](./02_CLASS_DIAGRAM.md) to understand entities
3. Explore [04_COMPONENT_DIAGRAM](./04_COMPONENT_DIAGRAM.md) to understand structure

### For Implementing Features
1. Check [04_COMPONENT_DIAGRAM](./04_COMPONENT_DIAGRAM.md) for patterns
2. See [05_DATA_FLOW](./05_DATA_FLOW.md) to understand flow
3. Use [03_SEQUENCE_FLOWS](./03_SEQUENCE_FLOWS.md) as reference

---

## üèóÔ∏è Quick Overview

### Architecture: {self.analysis.architecture_pattern}

**Confidence:** {self.analysis.confidence:.0%}

### Main Stack
```
{self._format_tech_stack_summary()}
```

---

*Last updated: {self.date}*
"""

    def _generate_architecture_overview(self) -> str:
        """Generate architecture overview with diagrams."""
        return f"""# System Architecture - {self.analysis.project_name}

## Architecture Overview

**Pattern:** {self.analysis.architecture_pattern}

```mermaid
{self._generate_architecture_mermaid()}
```

## Application Layers

```mermaid
{self._generate_layers_mermaid()}
```

## Technology Stack

| Layer | Technology | Purpose |
|-------|------------|---------|
{self._format_tech_stack_table()}

## Directory Structure

```
{self.analysis.directory_structure}
```

---

*Generated by Code Analysis Agent on {self.date}*
"""

    def _generate_class_diagram(self) -> str:
        """Generate class diagram documentation."""
        return f"""# Class Diagram - {self.analysis.project_name}

## Domain Model

```mermaid
{self._generate_class_mermaid()}
```

## Entity Descriptions

{self._generate_entities_description()}

---

*Generated by Code Analysis Agent on {self.date}*
"""

    def _generate_sequence_flows(self) -> str:
        """Generate sequence diagrams."""
        return f"""# Flows and Sequences - {self.analysis.project_name}

## Main Flows

{self._generate_main_flows_description()}

## Sequence Diagrams

```mermaid
{self._generate_sequence_mermaid()}
```

---

*Generated by Code Analysis Agent on {self.date}*
"""

    def _generate_component_diagram(self) -> str:
        """Generate component diagram."""
        return f"""# Component Diagram - {self.analysis.project_name}

## Component Hierarchy

```mermaid
{self._generate_component_mermaid()}
```

## Main Components

{self._generate_components_list()}

---

*Generated by Code Analysis Agent on {self.date}*
"""

    def _generate_data_flow_diagram(self) -> str:
        """Generate data flow diagram."""
        return f"""# Data Flow - {self.analysis.project_name}

## Flow Diagram

```mermaid
{self._generate_data_flow_mermaid()}
```

## Flow Description

{self._generate_flow_description()}

---

*Generated by Code Analysis Agent on {self.date}*
"""

    def _generate_dependency_graph_doc(self) -> str:
        """Generate dependency graph documentation."""
        stats = self.analysis.dependency_graph.get("stats", {})
        
        return f"""# Dependency Graph - {self.analysis.project_name}

## Statistics

| Metric | Value |
|--------|-------|
| Total Files | {stats.get('file_count', 'N/A')} |
| Total Functions | {stats.get('function_count', 'N/A')} |
| Total Classes | {stats.get('class_count', 'N/A')} |

## Overview

```mermaid
{self._generate_dependency_mermaid()}
```

## Most Connected Modules

{self._generate_connected_modules_list()}

---

*Generated by Code Analysis Agent on {self.date}*
"""

    def _generate_architecture_context(self) -> str:
        """Generate architecture context document."""
        return f"""# Architectural Context - {self.analysis.project_name}

> Quick reference guide about the project architecture.

**Architectural Pattern:** {self.analysis.architecture_pattern}  
**Last Updated:** {self.date}

---

## Architectural Decisions

{self._generate_architecture_description()}

## Patterns Used

{self._generate_patterns_summary()}

## Boundaries and Responsibilities

{self._generate_layer_responsibilities()}

---

*Generated by Code Analysis Agent*
"""

    def _generate_components_catalog(self) -> str:
        """Generate components catalog."""
        return f"""# Component Catalog - {self.analysis.project_name}

> Documentation of system components/modules.

**Last Updated:** {self.date}

---

{self._generate_full_components_catalog()}

---

*Generated by Code Analysis Agent*
"""

    def _generate_patterns_catalog(self) -> str:
        """Generate patterns catalog."""
        return f"""# Code Patterns - {self.analysis.project_name}

> Catalog of design patterns and conventions used in the project.

---

{self._generate_patterns_section()}

---

*Generated by Code Analysis Agent*
"""

    def _generate_tech_stack_doc(self) -> str:
        """Generate tech stack documentation."""
        return f"""# Technology Stack - {self.analysis.project_name}

> Documentation of project technologies and dependencies.

---

## Main Stack

{self._generate_tech_stack_section()}

---

*Generated by Code Analysis Agent*
"""

    def _generate_usage_index(self) -> str:
        """Generate usage index with decision tree."""
        return f"""# Usage Index - {self.analysis.project_name}

> Decision tree to navigate documentation. Start here.

---

## Quick Decision Tree

**What do you need to do?**
```
START HERE
    ‚îÇ
    ‚îú‚îÄ‚ñ∫ Starting on the project?
    ‚îÇ       ‚îÇ
    ‚îÇ       ‚îî‚îÄ‚ñ∫ 01_GETTING_STARTED.md
    ‚îÇ
    ‚îú‚îÄ‚ñ∫ Writing code?
    ‚îÇ       ‚îÇ
    ‚îÇ       ‚îú‚îÄ‚ñ∫ New component/module ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ 02_CODE_PATTERNS.md
    ‚îÇ       ‚îî‚îÄ‚ñ∫ Understand data flow ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ 03_DATA_FLOW.md
    ‚îÇ
    ‚îú‚îÄ‚ñ∫ Adding features?
    ‚îÇ       ‚îÇ
    ‚îÇ       ‚îî‚îÄ‚ñ∫ 04_ADDING_FEATURES.md
    ‚îÇ
    ‚îî‚îÄ‚ñ∫ Understanding architecture?
            ‚îÇ
            ‚îî‚îÄ‚ñ∫ See `/charts/00_INDEX.md` for diagrams
```

---

## Guide Summary

| # | Guide | When to Use |
|---|-------|-------------|
| 01 | GETTING_STARTED | First time on the project |
| 02 | CODE_PATTERNS | Writing code following patterns |
| 03 | DATA_FLOW | Understanding how data flows |
| 04 | ADDING_FEATURES | Adding new features |

---

## Rules for AI Agents

1. **Read this INDEX first** - don't load all guides
2. **Follow one path** - load only the guide matching the task
3. **Reference docs on demand** - only when the guide points to them

---

*Last updated: {self.date}*
"""

    def _generate_getting_started(self) -> str:
        """Generate getting started guide."""
        return f"""# Guide: Getting Started - {self.analysis.project_name}

> Step by step to setup and understand the project.

---

## Prerequisites

{self._generate_prerequisites()}

## Environment Setup

{self._generate_setup_steps()}

## First Steps

1. Clone the repository
2. Install dependencies
3. Configure environment variables (if applicable)
4. Run the project

## Useful Commands

{self._generate_commands()}

---

*Back to [Index](./00_INDEX.md)*
"""

    def _generate_code_patterns_guide(self) -> str:
        """Generate code patterns guide."""
        return f"""# Guide: Code Patterns - {self.analysis.project_name}

> How to write code following project patterns.

---

## Required Documents

Before creating code, check:

| Document | Path | Why |
|----------|------|-----|
| PATTERNS | `context/PATTERNS.md` | Design patterns used |
| COMPONENTS | `context/COMPONENTS.md` | Check if something similar already exists |

---

## Project Patterns

{self._generate_patterns_summary()}

## Examples

{self._generate_code_examples()}

---

*Back to [Index](./00_INDEX.md)*
"""

    def _generate_data_flow_guide(self) -> str:
        """Generate data flow guide."""
        return f"""# Guide: Data Flow - {self.analysis.project_name}

> How data flows through the system.

---

## Overview

{self._generate_flow_description()}

## Entry Points

{self._generate_entry_points_description()}

---

*Back to [Index](./00_INDEX.md)*
"""

    def _generate_adding_features_guide(self) -> str:
        """Generate adding features guide."""
        return f"""# Guide: Adding Features - {self.analysis.project_name}

> Step by step to add new features.

---

## Before Starting

1. Check if the feature already exists in `/docs/context/COMPONENTS.md`
2. Understand architecture in `/docs/charts/01_ARCHITECTURE_OVERVIEW.md`
3. Follow patterns in `/docs/context/PATTERNS.md`

## Step by Step

1. Identify which layer/module the feature belongs to
2. Create files in the correct structure
3. Follow naming conventions
4. Add tests
5. Update documentation if needed

## Final Checklist

- [ ] Code follows project patterns
- [ ] Tests were added
- [ ] Documentation updated
- [ ] Code review done

---

*Back to [Index](./00_INDEX.md)*
"""

    # =========================================
    # MERMAID DIAGRAM GENERATORS
    # =========================================

    def _generate_architecture_mermaid(self) -> str:
        """Generate architecture Mermaid diagram."""
        arch = self.analysis.architecture_pattern.lower()
        
        if "clean" in arch:
            return """flowchart TB
    subgraph External["üåê External"]
        UI[UI/API]
        DB[(Database)]
        ExtAPI[External APIs]
    end
    
    subgraph Adapters["üì¶ Adapters"]
        Controllers[Controllers]
        Repositories[Repositories]
        Gateways[Gateways]
    end
    
    subgraph Application["‚öôÔ∏è Application"]
        UseCases[Use Cases]
        Services[Services]
    end
    
    subgraph Domain["üíé Domain"]
        Entities[Entities]
        ValueObjects[Value Objects]
    end
    
    UI --> Controllers
    Controllers --> UseCases
    UseCases --> Entities
    UseCases --> Repositories
    Repositories --> DB
    UseCases --> Gateways
    Gateways --> ExtAPI"""
        
        elif "mvc" in arch:
            return """flowchart LR
    subgraph View["üëÅÔ∏è View"]
        Templates[Templates]
        Components[Components]
    end
    
    subgraph Controller["üéÆ Controller"]
        Routes[Routes]
        Handlers[Handlers]
    end
    
    subgraph Model["üì¶ Model"]
        Entities[Entities]
        Repositories[Repositories]
    end
    
    View <--> Controller
    Controller <--> Model"""
        
        elif "hexagonal" in arch or "ports" in arch:
            return """flowchart TB
    subgraph Inbound["‚¨ÖÔ∏è Inbound Adapters"]
        HTTP[HTTP API]
        CLI[CLI]
        Events[Event Listeners]
    end
    
    subgraph Core["üíé Core Domain"]
        subgraph Ports["Ports"]
            InPorts[Inbound Ports]
            OutPorts[Outbound Ports]
        end
        Domain[Domain Logic]
    end
    
    subgraph Outbound["‚û°Ô∏è Outbound Adapters"]
        DB[(Database)]
        ExtAPI[External APIs]
        Queue[Message Queue]
    end
    
    HTTP --> InPorts
    CLI --> InPorts
    Events --> InPorts
    InPorts --> Domain
    Domain --> OutPorts
    OutPorts --> DB
    OutPorts --> ExtAPI
    OutPorts --> Queue"""
        
        else:
            return """flowchart TB
    subgraph Presentation["üñ•Ô∏è Presentation"]
        UI[User Interface]
        API[API Layer]
    end
    
    subgraph Business["‚öôÔ∏è Business Logic"]
        Services[Services]
        Logic[Core Logic]
    end
    
    subgraph Data["üóÑÔ∏è Data Layer"]
        DB[(Database)]
        Cache[Cache]
    end
    
    UI --> Services
    API --> Services
    Services --> Logic
    Logic --> DB
    Logic --> Cache"""

    def _generate_layers_mermaid(self) -> str:
        """Generate layers diagram."""
        return """flowchart LR
    subgraph Presentation["Presentation Layer"]
        P1[Pages/Views]
        P2[Components]
        P3[Controllers]
    end
    
    subgraph Business["Business Layer"]
        B1[Services]
        B2[Use Cases]
        B3[Utils]
    end
    
    subgraph Data["Data Layer"]
        D1[Repositories]
        D2[APIs]
        D3[Cache]
    end
    
    Presentation --> Business
    Business --> Data"""

    def _generate_class_mermaid(self) -> str:
        """Generate class diagram from analysis."""
        # Extract classes from dependency graph
        nodes = self.analysis.dependency_graph.get("nodes", [])
        classes = [n for n in nodes if n.get("type") == "class"]
        
        if not classes:
            return """classDiagram
    class Entity {
        +id: string
        +createdAt: datetime
    }
    
    class Service {
        +execute()
    }
    
    Entity <-- Service : uses"""
        
        # Build class diagram from detected classes
        lines = ["classDiagram"]
        for cls in classes[:10]:  # Limit to 10 classes
            name = cls.get("name", "Unknown")
            lines.append(f"    class {name}")
        
        return "\n".join(lines)

    def _generate_sequence_mermaid(self) -> str:
        """Generate sequence diagram."""
        return """sequenceDiagram
    participant User
    participant Controller
    participant Service
    participant Repository
    participant Database
    
    User->>Controller: Request
    Controller->>Service: Process
    Service->>Repository: Query
    Repository->>Database: SQL
    Database-->>Repository: Data
    Repository-->>Service: Entity
    Service-->>Controller: Result
    Controller-->>User: Response"""

    def _generate_component_mermaid(self) -> str:
        """Generate component diagram."""
        modules = self.analysis.key_modules[:8] if self.analysis.key_modules else []
        
        if not modules:
            return """flowchart TB
    subgraph Core["Core"]
        Main[Main Module]
    end
    
    subgraph Features["Features"]
        F1[Feature 1]
        F2[Feature 2]
    end
    
    Main --> F1
    Main --> F2"""
        
        lines = ["flowchart TB"]
        for i, module in enumerate(modules):
            name = module if isinstance(module, str) else module.get("name", f"Module{i}")
            clean_name = name.replace("/", "_").replace("-", "_").replace(".", "_")
            lines.append(f"    {clean_name}[{name}]")
        
        return "\n".join(lines)

    def _generate_data_flow_mermaid(self) -> str:
        """Generate data flow diagram."""
        return """flowchart LR
    subgraph Input["üì• Input"]
        API[API Request]
        Event[Event]
    end
    
    subgraph Process["‚öôÔ∏è Processing"]
        Validate[Validation]
        Transform[Transform]
        Logic[Business Logic]
    end
    
    subgraph Output["üì§ Output"]
        DB[(Database)]
        Response[Response]
    end
    
    API --> Validate
    Event --> Validate
    Validate --> Transform
    Transform --> Logic
    Logic --> DB
    Logic --> Response"""

    def _generate_dependency_mermaid(self) -> str:
        """Generate dependency graph Mermaid."""
        edges = self.analysis.dependency_graph.get("edges", [])[:20]  # Limit edges
        
        if not edges:
            return """flowchart TB
    A[Module A] --> B[Module B]
    B --> C[Module C]"""
        
        lines = ["flowchart TB"]
        seen_nodes = set()
        
        for edge in edges:
            source = edge.get("source", "").replace("file:", "").split("/")[-1]
            target = edge.get("target", "").replace("file:", "").split("/")[-1]
            
            if source and target and source != target:
                # Clean names for Mermaid
                source_clean = source.replace(".", "_").replace("-", "_")[:20]
                target_clean = target.replace(".", "_").replace("-", "_")[:20]
                
                if source_clean not in seen_nodes:
                    lines.append(f"    {source_clean}[{source[:15]}]")
                    seen_nodes.add(source_clean)
                if target_clean not in seen_nodes:
                    lines.append(f"    {target_clean}[{target[:15]}]")
                    seen_nodes.add(target_clean)
                
                lines.append(f"    {source_clean} --> {target_clean}")
        
        return "\n".join(lines) if len(lines) > 1 else """flowchart TB
    A[Module A] --> B[Module B]"""

    # =========================================
    # TEXT CONTENT GENERATORS
    # =========================================

    def _generate_architecture_description(self) -> str:
        """Generate architecture description."""
        arch = self.analysis.architecture_pattern
        
        descriptions = {
            "Clean Architecture": """
This project follows **Clean Architecture**, separating code into concentric layers
where dependencies only point inward (towards the domain).

**Layers:**
- **Entities/Domain**: Enterprise business rules
- **Use Cases/Application**: Application business rules
- **Interface Adapters**: Controllers, Gateways, Presenters
- **Frameworks & Drivers**: Web, DB, external devices
""",
            "MVC": """
This project follows the **MVC (Model-View-Controller)** pattern.

**Components:**
- **Model**: Data and business logic
- **View**: User interface
- **Controller**: Orchestrates Model and View
""",
            "Hexagonal": """
This project follows **Hexagonal Architecture (Ports & Adapters)**.

**Components:**
- **Core Domain**: Business logic at the center
- **Ports**: Interfaces for input and output
- **Adapters**: Concrete implementations of ports
""",
        }
        
        for key, desc in descriptions.items():
            if key.lower() in arch.lower():
                return desc
        
        return f"""
The project follows a **{arch}** architecture.

Check diagrams at `/docs/charts/` for more details.
"""

    def _generate_patterns_section(self) -> str:
        """Generate patterns section."""
        if not self.analysis.patterns_detected:
            return "No specific patterns detected with high confidence."
        
        sections = []
        for p in self.analysis.patterns_detected:
            name = p.get("name", "Unknown")
            desc = p.get("description", "N/A")
            confidence = p.get("confidence", 0.5)
            evidence = p.get("evidence", [])
            
            section = f"""### {name}

**Confidence:** {confidence:.0%}

{desc}

**Evidence:**
{chr(10).join(f'- `{e}`' for e in evidence[:3]) if evidence else '- Inferred from analysis'}

---
"""
            sections.append(section)
        
        return "\n".join(sections)

    def _generate_patterns_summary(self) -> str:
        """Generate brief patterns summary."""
        if not self.analysis.patterns_detected:
            return "- Follow existing patterns in the code"
        
        return "\n".join(
            f"- **{p.get('name', 'Unknown')}**: {p.get('description', 'N/A')[:100]}"
            for p in self.analysis.patterns_detected[:5]
        )

    def _generate_tech_stack_section(self) -> str:
        """Generate tech stack section."""
        if not self.analysis.tech_stack:
            return f"""**Main Language:** {self.analysis.main_language}
{f"**Framework:** {self.analysis.framework}" if self.analysis.framework else ""}

Check `package.json`, `requirements.txt` or configuration files for details.
"""
        
        return "\n".join(
            f"| {k} | {v} |"
            for k, v in self.analysis.tech_stack.items()
        )

    def _format_tech_stack_summary(self) -> str:
        """Format tech stack for quick view."""
        stack = [self.analysis.main_language]
        if self.analysis.framework:
            stack.append(self.analysis.framework)
        if self.analysis.tech_stack:
            stack.extend(list(self.analysis.tech_stack.values())[:3])
        return "\n".join(stack[:5])

    def _format_tech_stack_table(self) -> str:
        """Format tech stack as table."""
        lines = []
        
        lines.append(f"| Language | {self.analysis.main_language} | Main language |")
        
        if self.analysis.framework:
            lines.append(f"| Framework | {self.analysis.framework} | Main framework |")
        
        for k, v in (self.analysis.tech_stack or {}).items():
            lines.append(f"| {k} | {v} | - |")
        
        return "\n".join(lines) if lines else "| - | - | - |"

    def _generate_improvements_section(self) -> str:
        """Generate improvements section."""
        if not self.analysis.improvements:
            return "No specific recommendations at this time."
        
        return "\n".join(f"- {imp}" for imp in self.analysis.improvements)

    def _generate_key_modules_description(self) -> str:
        """Generate key modules description."""
        if not self.analysis.key_modules:
            return "Check the directory structure above."
        
        return "\n".join(
            f"- **{m if isinstance(m, str) else m.get('name', 'Unknown')}**"
            for m in self.analysis.key_modules[:10]
        )

    def _generate_entry_points_description(self) -> str:
        """Generate entry points description."""
        if not self.analysis.entry_points:
            return "Check main files in the project root."
        
        return "\n".join(f"- `{ep}`" for ep in self.analysis.entry_points[:10])

    def _generate_entities_description(self) -> str:
        """Generate entities description from dependency graph."""
        nodes = self.analysis.dependency_graph.get("nodes", [])
        classes = [n for n in nodes if n.get("type") == "class"][:10]
        
        if not classes:
            return "Entities will be identified with deeper analysis."
        
        return "\n".join(
            f"### {cls.get('name', 'Unknown')}\n\nLocation: `{cls.get('path', 'N/A')}`\n"
            for cls in classes
        )

    def _generate_main_flows_description(self) -> str:
        """Generate main flows description."""
        return """The main system flows include:

1. **Input Flow** - Receiving and validating data
2. **Processing Flow** - Applying business rules
3. **Output Flow** - Responding to client

Check sequence diagrams below for details.
"""

    def _generate_components_list(self) -> str:
        """Generate components list."""
        if not self.analysis.key_modules:
            return "Components will be listed after deeper analysis."
        
        return "\n".join(
            f"### {m if isinstance(m, str) else m.get('name', 'Unknown')}\n\nSystem module.\n"
            for m in self.analysis.key_modules[:10]
        )

    def _generate_flow_description(self) -> str:
        """Generate data flow description."""
        return """Data flows through the following layers:

1. **Input**: APIs, events, commands
2. **Validation**: Data verification
3. **Processing**: Business logic
4. **Persistence**: Database, cache
5. **Output**: Responses, events
"""

    def _generate_connected_modules_list(self) -> str:
        """Generate list of most connected modules."""
        nodes = self.analysis.dependency_graph.get("nodes", [])
        
        # Count connections per module
        edges = self.analysis.dependency_graph.get("edges", [])
        connections = {}
        for edge in edges:
            source = edge.get("source", "")
            target = edge.get("target", "")
            connections[source] = connections.get(source, 0) + 1
            connections[target] = connections.get(target, 0) + 1
        
        # Sort by connections
        sorted_modules = sorted(connections.items(), key=lambda x: x[1], reverse=True)[:10]
        
        if not sorted_modules:
            return "Connection data not available."
        
        return "\n".join(
            f"- **{name.replace('file:', '')}**: {count} connections"
            for name, count in sorted_modules
        )

    def _generate_full_components_catalog(self) -> str:
        """Generate full components catalog."""
        files = self.analysis.files_read
        
        if not files:
            return "Components will be cataloged after file analysis."
        
        sections = []
        for f in files[:20]:  # Limit to 20 files
            path = f.get("path", "Unknown")
            summary = f.get("summary", "N/A")
            
            sections.append(f"""### `{path}`

{summary if summary else 'File analyzed.'}

---
""")
        
        return "\n".join(sections)

    def _generate_layer_responsibilities(self) -> str:
        """Generate layer responsibilities."""
        arch = self.analysis.architecture_pattern.lower()
        
        if "clean" in arch:
            return """
| Layer | Responsibility | Should Not |
|-------|----------------|------------|
| Domain | Business rules | Depend on frameworks |
| Application | Orchestrate use cases | Know infrastructure |
| Adapters | Convert data | Contain business logic |
| Infrastructure | Technical implementation | Contain business rules |
"""
        
        return "Check architecture documentation for specific responsibilities."

    def _generate_prerequisites(self) -> str:
        """Generate prerequisites."""
        lang = self.analysis.main_language.lower()
        
        if lang in ["python", "py"]:
            return """- Python 3.10+
- pip or poetry
- Git
"""
        elif lang in ["typescript", "javascript", "ts", "js"]:
            return """- Node.js 18+
- npm/yarn/pnpm
- Git
"""
        else:
            return f"""- {self.analysis.main_language}
- Git
- Check README.md for specific requirements
"""

    def _generate_setup_steps(self) -> str:
        """Generate setup steps."""
        lang = self.analysis.main_language.lower()
        
        if lang in ["python", "py"]:
            return """```bash
# Clone
git clone <repository-url>
cd <project>

# Virtual environment
python -m venv venv
source venv/bin/activate  # or venv\\Scripts\\activate on Windows

# Dependencies
pip install -r requirements.txt
# or: poetry install
```
"""
        elif lang in ["typescript", "javascript", "ts", "js"]:
            return """```bash
# Clone
git clone <repository-url>
cd <project>

# Dependencies
npm install
# or: yarn / pnpm install
```
"""
        else:
            return "Check README.md for setup instructions."

    def _generate_commands(self) -> str:
        """Generate useful commands."""
        lang = self.analysis.main_language.lower()
        
        if lang in ["python", "py"]:
            return """```bash
# Run
python main.py
# or: python -m src

# Tests
pytest

# Lint
ruff check .
```
"""
        elif lang in ["typescript", "javascript", "ts", "js"]:
            return """```bash
# Development
npm run dev

# Build
npm run build

# Tests
npm run test
```
"""
        else:
            return "Check README.md for specific commands."

    def _generate_code_examples(self) -> str:
        """Generate code examples."""
        return """Check existing files in the repository for code examples
that follow project patterns.
"""


def generate_documentation(
    project_name: str,
    architecture_pattern: str,
    confidence: float,
    main_language: str,
    files_read: list,
    patterns_detected: list,
    dependency_graph: dict,
    directory_structure: str = "",
    framework: str = None,
    tech_stack: dict = None,
    improvements: list = None,
    entry_points: list = None,
    key_modules: list = None,
    output_format: str = "summary",  # "summary" or "full"
) -> str | dict[str, str]:
    """
    Convenience function to generate documentation.
    
    Args:
        project_name: Name of the project
        architecture_pattern: Detected architecture
        confidence: Analysis confidence (0-1)
        main_language: Main programming language
        files_read: List of files analyzed
        patterns_detected: List of detected patterns
        dependency_graph: Dependency graph data
        directory_structure: Directory tree string
        framework: Framework used
        tech_stack: Technology stack
        improvements: List of improvement suggestions
        entry_points: List of entry point files
        key_modules: List of key modules
        output_format: "summary" for single file, "full" for complete structure
        
    Returns:
        Single markdown string or dict of file paths to content
    """
    analysis = AnalysisResult(
        project_name=project_name,
        architecture_pattern=architecture_pattern,
        confidence=confidence,
        main_language=main_language,
        framework=framework,
        patterns_detected=patterns_detected or [],
        files_read=files_read or [],
        tech_stack=tech_stack or {},
        directory_structure=directory_structure or "",
        dependency_graph=dependency_graph or {},
        improvements=improvements or [],
        entry_points=entry_points or [],
        key_modules=key_modules or [],
    )
    
    generator = DocumentationGenerator(analysis)
    
    if output_format == "full":
        return generator.generate_full_documentation()
    else:
        return generator.generate_summary_documentation()
